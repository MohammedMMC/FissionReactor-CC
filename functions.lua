local M,REACTOR_NAME={},"fissionReactorLogicAdapter_0"
local sp,sn,lastClock=nil,nil,0
local DI=5
local function onlyMode(ms) if #ms~=5 then return false end local e={decrementMode=1,getMode=1,help=1,incrementMode=1,setMode=1};for _,m in ipairs(ms) do if not e[m] then return false end end return true end
local function amt(v) if type(v)=='number' then return v end if type(v)=='table' then if type(v.amount)=='number' then return v.amount end if type(v.stored)=='number' then return v.stored end if type(v.value)=='number' then return v.value end if type(v.amount)=='table' and type(v.amount.amount)=='number' then return v.amount.amount end end end
local function cap(v) if type(v)=='table' then if type(v.capacity)=='number' then return v.capacity end if type(v.max)=='number' then return v.max end if type(v.limit)=='number' then return v.limit end if type(v.capacity)=='table' and type(v.capacity.amount)=='number' then return v.capacity.amount end end end
local function heat(v) if type(v)=='number' then return v end if type(v)=='table' then if type(v.temperature)=='number' then return v.temperature end if type(v.heat)=='number' then return v.heat end if type(v.temp)=='number' then return v.temp end local a=amt(v);if a then return a end end end
local function call(o,m,...) if not o then return end local f=o[m]; if type(f)~='function' then return end local ok,r=pcall(f,...) if ok then return r end end
local function first(o,ms,...) for _,m in ipairs(ms) do local v=call(o,m,...) if v~=nil then return v end end end
local function discover() sp,sn=nil,nil for _,n in ipairs(peripheral.getNames()) do local ms=peripheral.getMethods(n) or {} if not onlyMode(ms) then local sig={} for _,m in ipairs(ms) do sig[m]=true end if sig.getFuel or sig.getFuelAmount or sig.getCoolant or sig.getBurnRate or sig.getStatus or n==REACTOR_NAME then sp=peripheral.wrap(n) sn=n break end end end if (not sp) and REACTOR_NAME and peripheral.isPresent(REACTOR_NAME) then local ms=peripheral.getMethods(REACTOR_NAME) or {} if not onlyMode(ms) then sp=peripheral.wrap(REACTOR_NAME) sn=REACTOR_NAME end end lastClock=os.clock() end
local function ensure() if not sp then discover() return end if os.clock()-lastClock>DI then discover() end end
local function resource(currM,capM,t) ensure() if not sp then return end local raw=first(sp,currM) local c=amt(raw) if type(c)~='number' then c=type(raw)=='number' and raw or nil end local C=first(sp,capM) if type(C)~='number' then C=cap(C) end if not C and raw then C=cap(raw) end if t=='max' then return C end if t=='percent' then if c and C and C>0 then return c/C*100 end return end return c end
function M.setReactorName(n) REACTOR_NAME=n discover() end
function M.getStatus() ensure() if not sp then return end local v=first(sp,{'getStatus','isFormed','isActive','getActive','isRunning','getRunning','isStarted'}) if type(v)=='boolean' then return v end if type(v)=='string' then local l=v:lower() return l=='active' or l=='running' end if type(v)=='number' then return v~=0 end end
function M.getDamage() ensure() if not sp then return end local d=first(sp,{'getDamagePercent','getDamage','getCasingDamage'}) return type(d)=='number' and d or nil end
function M.getTemp() ensure() if not sp then return end local t=first(sp,{'getTemperature','getTemp','getHeat','getReactorTemperature','getCoreTemperature','getCoreTemp','getCaseTemperature','getCasingTemperature','getFuelTemperature','getInternalTemperature','getInternalTemp'}) return heat(t) end
function M.getHeatingRate() ensure() if not sp then return end local h=first(sp,{'getHeatingRate','getHeatRate','getPassiveGeneration','getPassiveHeatGeneration','getPassive','getLastHeatingRate','getHeatPerTick','getHeatGeneration'}) if type(h)=='number' then return h end if h then return heat(h) or amt(h) end end
function M.getBurnRate(t) ensure() if not sp then return end local c=first(sp,{'getBurnRate','getConfiguredBurnRate','getSetBurnRate'}); if c and type(c)~='number' then c=amt(c) end local m=first(sp,{'getMaxBurnRate','getMaximumBurnRate','getMaxConfiguredBurnRate','getMaxAllowedBurnRate'}); if m and type(m)~='number' then m=amt(m) end if t=='max' then return m end if t=='percent' then if c and m and m>0 then return c/m*100 end return end return c end
function M.getFuel(t) return resource({'getFuel','getFuelAmount'},{'getFuelCapacity','getMaxFuel','getFuelAmountCapacity'},t) end
function M.getWaste(t) return resource({'getWaste','getWasteAmount'},{'getWasteCapacity','getMaxWaste','getWasteAmountCapacity'},t) end
function M.getCoolant(t) return resource({'getCoolant','getCoolantAmount'},{'getCoolantCapacity','getMaxCoolant','getCoolantAmountCapacity'},t) end
function M.getHeatedCoolant(t) return resource({'getHeatedCoolant','getHeatedCoolantAmount','getHotCoolant','getHotCoolantAmount'},{'getHeatedCoolantCapacity','getHotCoolantCapacity','getHeatedCoolantAmountCapacity'},t) end
function M.setStatus(d) ensure() if not sp then return false,'no peripheral' end if type(d)~='boolean' then return false,'expected boolean' end local f=sp.setActive if type(f)=='function' then local ok,e=pcall(f,d) if ok then return true else return false,tostring(e) end end f=sp.setStatus if type(f)=='function' then local ok,e=pcall(f,d) if ok then return true else return false,tostring(e) end end if d and type(sp.activate)=='function' then local ok,e=pcall(sp.activate) if ok then return true else return false,tostring(e) end elseif (not d) and type(sp.deactivate)=='function' then local ok,e=pcall(sp.deactivate) if ok then return true else return false,tostring(e) end end if (not d) and type(sp.scram)=='function' then local ok,e=pcall(sp.scram) if ok then return true else return false,tostring(e) end end return false,'no suitable status method' end
function M.setBurnRate(r) ensure() if not sp then return false,'no peripheral' end if type(r)~='number' then return false,'expected number' end local f=sp.setBurnRate or sp.setConfiguredBurnRate if type(f)~='function' then return false,'no setBurnRate method' end local ok,e=pcall(f,r) if ok then return true else return false,tostring(e) end end
return M
